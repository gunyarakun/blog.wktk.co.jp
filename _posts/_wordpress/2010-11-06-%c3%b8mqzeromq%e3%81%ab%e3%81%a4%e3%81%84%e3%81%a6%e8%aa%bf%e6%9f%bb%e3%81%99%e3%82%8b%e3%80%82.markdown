---
layout: !binary |-
  cG9zdA==
status: !binary |-
  cHVibGlzaA==
published: true
title: ! '&Oslash;MQ(zeromq)について調査する。'
author: !binary |-
  dGFzdWt1
author_login: !binary |-
  dGFzdWt1
author_email: !binary |-
  YmxvZ0B3a3RrLmNvLmpw
wordpress_id: 71
wordpress_url: !binary |-
  aHR0cDovL2Jsb2cud2t0ay5jby5qcC8/cD03MQ==
date: 2010-11-06 06:32:14.000000000 +09:00
categories:
- 技術メモ
tags: []
comments: []
---
<a href="http://www.zeromq.org/">&Oslash;MQ(zeromq)</a>について簡単に調査したのでメモ。元ネタは<a href="http://zguide.zeromq.org/chapter:all">&Oslash;MQ - The Guide</a>。
<h2>概要</h2>
<ul>
	<li>N-N通信を実現する、socket API風軽量メッセージングライブラリ。</li>
	<li>自動的な再接続や、メッセージのキューイングを行ってくれる。</li>
	<li>複数のメッセージングパターンと呼ばれるものを組み合わせることによって、柔軟なメッセージ配信を行うことができる。</li>
</ul>
<h2>ライブラリについて</h2>
<ul>
	<li>socket APIライクなC APIを持つ。以下socketは、zeromqのsocketを指す。</li>
	<li>zeromqはコンテキストというものを通じて使う。1コンテキストに、I/Oスレッドが1つ割り当てられる。基本1プロセスに1コンテキストでOK。複数のcontextを持つことはできるし、その場合は同じ個数のI/Oスレッドが走る。</li>
	<li>zeromqのsocketは、プロセス内通信(スレッド間通信など)、プロセス間通信、TCP、UDPマルチキャストをラップしたものである。icp:my.serverや、tcp:127.0.0.1:1234のようにしてラップ先を設定できる。</li>
	<li>通信では、メッセージをやりとりする。メッセージは複数のフレームからなる。１つのフレームは、１つの長さ付きバイナリを持つ。</li>
	<li>1つのsocketで、N-N通信ができる。</li>
	<li>1つのノードは、複数のsocketを持つことができる。</li>
	<li>zeromqのsocketは本物のsocketとは違い、クライアントを先に起動することができる。</li>
	<li>接続には、メッセージングパターンというものが設定されている。パターンによってメッセージ送受信方法が変わる。後述。</li>
	<li>サーバはデータの送信者、クライアントはデータの受信者では「ない」。あくまで、メッセージングパターンに基づいてメッセージがやりとりされる。</li>
	<li>ノードは、動的に追加できる。</li>
	<li>メッセージングパターンが用いるメタ情報を除いて、zeromqはメッセージの内容を関知しない。</li>
</ul>
<h2>キューについて</h2>
<ul>
	<li>メッセージは、メッセージングパターンに応じて送信時・受信時にキューイングされる。</li>
	<li>キューはロックレスで、基本オンメモリ。</li>
	<li>送信キューにたまったメッセージは、I/Oスレッドが送信してくれる。非同期I/Oが用いられる。</li>
	<li>メッセージ送信APIはただ単にメッセージを送信キューに入れるだけ。</li>
	<li>I/Oスレッドが、メッセージは受信キューに受信し続けてくれる。非同期I/Oが用いられる。</li>
	<li>メッセージ受信APIはただ単にメッセージを受信キューから読み出すだけ。</li>
	<li>キューのサイズを指定することができる。</li>
	<li>ZMQ_SWAPオプションで、オンメモリ上のキューからあふれたメッセージをディスク上に書き出すことができる。ただし、そのファイルを再利用することはできない。あくまで、一時的な領域としてディスクを使うだけ。</li>
</ul>
<h2>メッセージングパターンについて</h2>
<ul>
	<li>REQ/REP/PUB/SUB/PUSH/PULL/XREQ/XREP/PAIRがある。</li>
</ul>
<h3>REQ/REPについて</h3>
<ul>
	<li>request-replyモデル。リクエストを行い、そのレスポンスを受け取る通信方式。</li>
	<li>REQがリクエストを行う側。複数のノードと接続している場合には、そのうち1つのノードにリクエストメッセージを送信する。</li>
	<li>REPがレスポンスを返す側。リクエストメッセージを送ってきたノードにレスポンスメッセージを送信する。</li>
	<li>REQ側はレスポンスを受け取るまで新たなリクエストを出来ないし、REP側はレスポンスを返すまで他のリクエストを受け取れないようになっている。</li>
	<li>これらの問題を解決するXREQ/XREPについては後述。</li>
</ul>
<h3>PUB/SUBについて</h3>
<ul>
	<li>publish-subscribeモデル。publish側がメッセージを流しつづけ、それを複数のsubscribe側が受けとることができる。</li>
	<li>メッセージにはkey部分とdata部分がある。</li>
	<li>PUB側は、key部分とdata部分を送る。</li>
	<li>SUB側は、特定のkeyを先頭に持つメッセージを受信する。複数のkeyについてメッセージを受信できる。</li>
	<li>SUB側は、keyを指定しないとメッセージを受け取ることができない。空文字列をkeyとして指定した場合、すべてのメッセージを受け取ることができる。</li>
	<li>key部分とdata部分は、同じフレーム内にあってもよい。ただし、keyの誤マッチが起こる可能性がある。keyとdataでフレームを分けることによって、誤マッチは避けることができる。</li>
	<li>PUB側がサーバである必要はない。SUB側がサーバとなることもできる。</li>
	<li>PUB側はデータ送信キューを持つ。キューがいっぱいの場合には、キューへの投入はただ無視される。</li>
	<li>SUB側はデータ受信キューを持つ。</li>
</ul>
<h3>PUSH/PULLについて</h3>
<ul>
	<li>pipelineモデル。PUB/SUBとは異なり、メッセージの受取り手はノード群のうちの1つのノードとなる。</li>
	<li>PUSH側がサーバである必要はない。PULL側がサーバとなることもできる。</li>
	<li>複数PULLの場合には、ロードバランシングによってそれぞれのPULL側にメッセージが割り振られる。</li>
	<li>複数PUSHの場合には、PULL側ではそれぞれのPUSH側から１つずつメッセージを順番に読むような感じになる。</li>
	<li>PUSH側はデータ送信キューを持つ。初めて接続されたPULL側にそれまで送ったメッセージが一気に送信されてしまう。複数のPULL側がいる場合には、それらをすべて起動してからPUSH側を立ち上げること。</li>
</ul>
<h3>PAIRについて</h3>
<ul>
	<li>同期のために用いる。1-1接続のみ。</li>
	<li>PUSH/PULL、XREQ/XREP、PUB/SUBを同期目的に使うのは問題がある。</li>
</ul>
<h3>REQ/REP/XREQ/XREPについて</h3>
<ul>
	<li>XREQ/XREPを使うことによって、メッセージをルーティングすることができる。</li>
</ul>
<ul>
	<li>REQは、リクエストするメッセージの先頭に空のフレームを付与し、受け取ったレスポンスの先頭にある空のフレームを削除する。</li>
	<li>REPは、受け取ったリクエストメッセージの、先頭から空のフレームまでのフレームを保存する。送信するレスポンスの先頭に、保存したフレーム群を付与する。</li>
	<li>よって、REQ/REPの組み合わせでは、REQ側が付与した空のフレームをREP側がそのまま返却し、REQ側がその空のフレームを取り除くことになる。</li>
</ul>
<ul>
	<li>XREQは、接続しているすべてのノードに対してロードバランシングをしたリクエストを送り、それらのノード群からレスポンスを受け取る。</li>
	<li>XREQによる、リクエスト送信とレスポンス受信は対応していない。XREQはPUSH/PULLを兼ねたイメージで捉えるとよい。</li>
	<li>XREQは、メッセージ中のフレーム操作を行わない。</li>
</ul>
<ul>
	<li>XREPは、リクエストされたメッセージの先頭に、接続相手のノードIDが入ったフレームを付与する</li>
	<li>ノードIDはXREPの相手側が明示的に指定することができる。</li>
	<li>ノードIDが指定されない場合には、UUIDが使われる。</li>
	<li>XREPは、レスポンスメッセージの先頭のフレームを削除し、そのフレームに書いてあったノードIDにのみレスポンスメッセージを返却する。</li>
</ul>
<ul>
	<li>多段ルーティングなども、これらの仕組みを組み合わせて実現される。</li>
</ul>
<h3>デバイスとは</h3>
<ul>
	<li>zeromqでは、上記のメッセージングパターンを組み合わせることによって、柔軟なネットワークを構成することができる。</li>
	<li>メッセージングパターン同士を仲介するノードを、デバイスと呼ぶ。</li>
	<li>zeromqは、いくつかの組み込みデバイスを持つ。</li>
	<li>組み込みデバイスQUEUEは、REQから受け取ったリクエストを、複数のREPに送信し、その結果をREQに返すデバイス。</li>
	<li>組み込みデバイスFORWARDERは、PUB/SUBを再送信する。PUB/SUBをスケールさせるには、木構造通信を行う必要がある。そのときに、根ノード以外の内部ノードとして用いることができる。</li>
	<li>組み込みデバイスSTREAMERは、PUSH/PULLでFORWARDERの役割を果たすものである。</li>
</ul>
<ul>
	<li>メッセージングパターンの組み合わせとして、PUB-SUB，REQ-REP，REQ-XREP，XREQ-REP，XREQ-XREP，XREQ-XREQ，XREP-XREP，PUSH-PULL，PAIR-PAIRが存在する。</li>
	<li>これらのメッセージングパターンを組み合わせて、さまざまなトポロジやルーティングなどを実現することができる。</li>
</ul>
<h2>その他俺メモ</h2>
<ul>
	<li>Debianの公式パッケージになっていない。ITPは出ているので、じきに入るだろう。</li>
	<li>Debianの場合、ビルドにuuid-devパッケージもしくはe2fslibs-devが必要。uuid-devは、e2fslibs内で使われているUUID生成ライブラリlibuuidだけをパッケージとしたもの。</li>
	<li>足周りのTCPやIPCは完全に隠蔽される。横からいじることはできない。</li>
	<li>メッセージングパターンの組み合わせは、<a href="http://zguide.zeromq.org/chapter:all">http://zguide.zeromq.org/chapter:all</a> を参考にすること。</li>
	<li>メッセージングパターンの複雑な組み合わせ例として、<a href="http://ipython.scipy.org/doc/nightly/html/development/parallel_connections.html">http://ipython.scipy.org/doc/nightly/html/development/parallel_connections.html</a> が挙げられる。</li>
</ul>
<h2>感想</h2>
<ul>
	<li>簡単にN-N通信が出来るのは魅力。APIの数も少ないし、各種言語バインディングがそろっているのもいい。</li>
	<li>その名前からか、「キュー」という紹介のされ方をされている場合がある。冒頭に述べたように、N-N socket通信ライブラリと捉えたほうが適切ではないか。確かにキューイングはしてくれるけど。</li>
	<li>キューは永続化されない。REQ/REPの組み合わせでレスポンスを確認したりして、データが確実に先方に伝わったことを確認しない場合は、データは消えてもいい覚悟で使うのがいいだろう。</li>
	<li>メッセージングパターンの組み合わせで柔軟な通信は出来そうなのはわかったが、具体的なレシピがいっぱいあるとうれしい。</li>
	<li>tcp:での利用が多いんだろうが、inproc:やipc:も使いでがありそう。</li>
	<li>PUB/SUBでSUB側がサーバになれるのがうれしい。例えば、ログ収集サーバとしてSUB側を立て、動的にPUB側を増やすことが出来る。この用途で使ってみたいと考える。んでも、PUB/SUBでSUB側が1台しかないんだったら、PUSH/PULLでも充分だと今気づいた。</li>
	<li>PythonやRubyバインディングで遊んでみると理解が早い。C言語レベルで使いやすいAPIなので、LLでトポロジ設計をしたあとにC言語でガッツリ書く、というポリシーだとハイパフォーマンスな用途にも簡単に使えそうだ。</li>
</ul>
